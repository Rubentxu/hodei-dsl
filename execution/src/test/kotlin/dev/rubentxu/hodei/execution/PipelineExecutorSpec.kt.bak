package dev.rubentxu.hodei.execution

import dev.rubentxu.hodei.core.domain.model.*
import dev.rubentxu.hodei.execution.*
import io.kotest.core.spec.style.BehaviorSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.matchers.types.shouldBeInstanceOf
import io.kotest.matchers.collections.shouldHaveSize
import io.kotest.matchers.longs.shouldBeGreaterThan
import io.kotest.assertions.throwables.shouldThrow
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import java.time.Duration
import kotlin.time.Duration.Companion.milliseconds
import kotlin.time.Duration.Companion.seconds

/**
 * BDD Specification for PipelineExecutor
 * 
 * Tests the complete pipeline execution engine including structured concurrency,
 * parallel execution, error handling, timeouts, and event-driven communication.
 * Ensures proper resource cleanup and performance characteristics.
 */
class PipelineExecutorSpec : BehaviorSpec({
    
    given("a PipelineExecutor") {
        val executor = PipelineExecutor()
        val context = ExecutionContext.default()
        
        `when`("executing a simple sequential pipeline") {
            then("should execute all stages in order") {
                val pipeline = Pipeline.builder()
                    .stage("Build") {
                        steps {
                            sh("echo 'Building...'")
                            sh("gradle build")
                        }
                    }
                    .stage("Test") {
                        steps {
                            sh("echo 'Testing...'")
                            sh("gradle test")
                        }
                    }
                    .build()
                
                val result = executor.execute(pipeline, context)
                
                result.status shouldBe PipelineStatus.SUCCESS
                result.stages shouldHaveSize 2
                result.stages[0].stageName shouldBe "Build"
                result.stages[1].stageName shouldBe "Test"
                result.stages.all { it.status == StageStatus.SUCCESS } shouldBe true
                result.duration.toMillis() shouldBeGreaterThan 0L
                result.executionId shouldNotBe null
            }
        }
        
        `when`("executing a pipeline with parallel stages") {
            then("should execute branches concurrently").config(enabled = false) {
                val pipeline = Pipeline.builder()
                    .stage("Build") {
                        steps {
                            sh("echo 'Building...'")
                        }
                    }
                    .stage("Test") {
                        parallel {
                            branch("Unit Tests") {
                                sh("sleep 1")
                                sh("echo 'Unit tests completed'")
                            }
                            branch("Integration Tests") {
                                sh("sleep 1") 
                                sh("echo 'Integration tests completed'")
                            }
                            branch("E2E Tests") {
                                sh("sleep 1")
                                sh("echo 'E2E tests completed'")
                            }
                        }
                    }
                    .build()
                
                val startTime = System.currentTimeMillis()
                val result = executor.execute(pipeline, context)
                val totalTime = System.currentTimeMillis() - startTime
                
                result.status shouldBe PipelineStatus.SUCCESS
                result.stages shouldHaveSize 2
                
                val testStage = result.stages[1]
                testStage.stageName shouldBe "Test"
                testStage.branches shouldHaveSize 3
                testStage.branches?.all { it.status == StageStatus.SUCCESS } shouldBe true
                
                // Parallel execution should be faster than sequential
                totalTime shouldBeGreaterThan 1000L // At least 1 second
                totalTime shouldBeLessThan 2500L    // But less than 2.5 seconds (parallel benefit)
            }
        }
        
        `when`("executing a pipeline with conditional stages") {
            then("should evaluate when conditions correctly") {
                val pipeline = Pipeline.builder()
                    .stage("Build") {
                        steps {
                            sh("echo 'Building...'")
                        }
                    }
                    .stage("Deploy to Staging") {
                        `when` {
                            branch("develop")
                        }
                        steps {
                            sh("echo 'Deploying to staging...'")
                        }
                    }
                    .stage("Deploy to Production") {
                        `when` {
                            branch("main")
                        }
                        steps {
                            sh("echo 'Deploying to production...'")
                        }
                    }
                    .build()
                
                // Test with develop branch
                val devContext = context.copy(
                    environment = context.environment + ("GIT_BRANCH" to "develop")
                )
                val devResult = executor.execute(pipeline, devContext)
                
                devResult.status shouldBe PipelineStatus.SUCCESS
                devResult.stages shouldHaveSize 3
                devResult.stages[0].status shouldBe StageStatus.SUCCESS // Build
                devResult.stages[1].status shouldBe StageStatus.SUCCESS // Deploy to Staging
                devResult.stages[2].status shouldBe StageStatus.SKIPPED // Deploy to Production
            }
        }
        
        `when`("executing a pipeline with global timeout") {
            then("should cancel execution when timeout exceeded") {
                val pipeline = Pipeline.builder()
                    .timeout(500.milliseconds)
                    .stage("Long Running") {
                        steps {
                            sh("sleep 2") // This will exceed timeout
                        }
                    }
                    .build()
                
                shouldThrow<PipelineTimeoutException> {
                    executor.execute(pipeline, context)
                }
            }
        }
        
        `when`("executing a pipeline with stage timeout") {
            then("should timeout individual stage without affecting others") {
                val pipeline = Pipeline.builder()
                    .stage("Fast Stage") {
                        steps {
                            sh("echo 'Fast stage completed'")
                        }
                    }
                    .stage("Slow Stage") {
                        timeout(200.milliseconds)
                        steps {
                            sh("sleep 1") // This will timeout
                        }
                    }
                    .stage("Recovery Stage") {
                        steps {
                            sh("echo 'Recovery completed'")
                        }
                    }
                    .build()
                
                val result = executor.execute(pipeline, context)
                
                result.status shouldBe PipelineStatus.PARTIAL_SUCCESS
                result.stages shouldHaveSize 3
                result.stages[0].status shouldBe StageStatus.SUCCESS
                result.stages[1].status shouldBe StageStatus.TIMEOUT
                result.stages[2].status shouldBe StageStatus.SUCCESS
            }
        }
        
        `when`("executing a pipeline with fail-fast enabled") {
            then("should stop execution on first failure") {
                val pipeline = Pipeline.builder()
                    .stage("Success Stage") {
                        steps {
                            sh("echo 'This should succeed'")
                        }
                    }
                    .stage("Failing Stage") {
                        failFast(true)
                        steps {
                            sh("exit 1") // This will fail
                        }
                    }
                    .stage("Should Not Execute") {
                        steps {
                            sh("echo 'This should not execute'")
                        }
                    }
                    .build()
                
                val result = executor.execute(pipeline, context)
                
                result.status shouldBe PipelineStatus.FAILURE
                result.stages shouldHaveSize 2 // Third stage should not execute
                result.stages[0].status shouldBe StageStatus.SUCCESS
                result.stages[1].status shouldBe StageStatus.FAILURE
            }
        }
        
        `when`("executing multiple pipelines concurrently") {
            then("should handle concurrent executions safely") {
                val pipeline1 = Pipeline.builder()
                    .stage("Pipeline 1") {
                        steps {
                            sh("echo 'Pipeline 1 executing'")
                            sh("sleep 0.5")
                        }
                    }
                    .build()
                
                val pipeline2 = Pipeline.builder()
                    .stage("Pipeline 2") {
                        steps {
                            sh("echo 'Pipeline 2 executing'")
                            sh("sleep 0.3")
                        }
                    }
                    .build()
                
                val pipeline3 = Pipeline.builder()
                    .stage("Pipeline 3") {
                        steps {
                            sh("echo 'Pipeline 3 executing'")
                            sh("sleep 0.7")
                        }
                    }
                    .build()
                
                runBlocking {
                    val results = listOf(
                        async { executor.execute(pipeline1, context) },
                        async { executor.execute(pipeline2, context) },
                        async { executor.execute(pipeline3, context) }
                    ).awaitAll()
                    
                    results.forEach { result ->
                        result.status shouldBe PipelineStatus.SUCCESS
                        result.executionId shouldNotBe null
                    }
                    
                    // All executions should have unique execution IDs
                    val executionIds = results.map { it.executionId }.toSet()
                    executionIds shouldHaveSize 3
                }
            }
        }
        
        `when`("pipeline execution fails with error") {
            then("should provide detailed error information") {
                val pipeline = Pipeline.builder()
                    .stage("Failing Stage") {
                        steps {
                            sh("nonexistent-command") // This will fail
                        }
                    }
                    .build()
                
                val result = executor.execute(pipeline, context)
                
                result.status shouldBe PipelineStatus.FAILURE
                result.error shouldNotBe null
                result.error?.message shouldNotBe null
                result.stages.first().error shouldNotBe null
            }
        }
        
        `when`("using event listener for pipeline execution") {
            then("should receive all pipeline events") {
                val events = mutableListOf<PipelineEvent>()
                val eventListener = object : PipelineEventListener {
                    override suspend fun onEvent(event: PipelineEvent) {
                        events.add(event)
                    }
                }
                
                val executorWithListener = PipelineExecutor(
                    config = ExecutorConfig.builder()
                        .eventListener(eventListener)
                        .build()
                )
                
                val pipeline = Pipeline.builder()
                    .stage("Test Stage") {
                        steps {
                            sh("echo 'Test step'")
                        }
                    }
                    .build()
                
                executorWithListener.execute(pipeline, context)
                
                events.shouldNotBeEmpty()
                events.any { it is PipelineEvent.PipelineStarted } shouldBe true
                events.any { it is PipelineEvent.StageStarted } shouldBe true
                events.any { it is PipelineEvent.StepStarted } shouldBe true
                events.any { it is PipelineEvent.StepCompleted } shouldBe true
                events.any { it is PipelineEvent.StageCompleted } shouldBe true
                events.any { it is PipelineEvent.PipelineCompleted } shouldBe true
            }
        }
        
        `when`("pipeline execution is cancelled") {
            then("should perform cleanup and resource release") {
                val pipeline = Pipeline.builder()
                    .stage("Long Running") {
                        steps {
                            sh("sleep 10") // Long running task
                        }
                    }
                    .build()
                
                runBlocking {
                    val job = async {
                        executor.execute(pipeline, context)
                    }
                    
                    delay(100) // Let execution start
                    job.cancel() // Cancel the execution
                    
                    shouldThrow<kotlinx.coroutines.CancellationException> {
                        job.await()
                    }
                }
            }
        }
    }
    
    given("a PipelineExecutor with custom configuration").config(enabled = false) {
        `when`("using custom dispatcher configuration") {
            then("should use appropriate dispatchers for different workloads") {
                val customConfig = ExecutorConfig.builder()
                    .maxConcurrentPipelines(5)
                    .defaultStageTimeout(30.seconds)
                    .enableMetrics(true)
                    .build()
                
                val executor = PipelineExecutor(customConfig)
                
                val pipeline = Pipeline.builder()
                    .stage("CPU Intensive") {
                        workloadType(WorkloadType.CPU_INTENSIVE)
                        steps {
                            sh("echo 'CPU intensive task'")
                        }
                    }
                    .stage("IO Intensive") {
                        workloadType(WorkloadType.IO_INTENSIVE)
                        steps {
                            sh("echo 'IO intensive task'")
                        }
                    }
                    .build()
                
                val result = executor.execute(pipeline, context)
                
                result.status shouldBe PipelineStatus.SUCCESS
                result.stages.forEach { stage ->
                    stage.metadata["dispatcher"] shouldNotBe null
                    stage.metadata["thread"] shouldNotBe null
                }
            }
        }
        
        `when`("using metrics collection") {
            then("should collect comprehensive execution metrics") {
                val metricsCollector = TestMetricsCollector()
                val config = ExecutorConfig.builder()
                    .metricsCollector(metricsCollector)
                    .enableMetrics(true)
                    .build()
                
                val executor = PipelineExecutor(config)
                
                val pipeline = Pipeline.builder()
                    .stage("Measured Stage") {
                        steps {
                            sh("echo 'Collecting metrics...'")
                        }
                    }
                    .build()
                
                executor.execute(pipeline, context)
                
                metricsCollector.pipelineStartEvents shouldBeGreaterThan 0
                metricsCollector.pipelineCompletionEvents shouldBeGreaterThan 0
                metricsCollector.stageExecutionEvents shouldBeGreaterThan 0
                metricsCollector.stepExecutionEvents shouldBeGreaterThan 0
            }
        }
    }
})

/**
 * Test implementation of metrics collector for verification
 */
private class TestMetricsCollector : ExecutionMetricsCollector {
    var pipelineStartEvents = 0
    var pipelineCompletionEvents = 0
    var stageExecutionEvents = 0
    var stepExecutionEvents = 0
    
    override fun recordPipelineStart(executionId: String, pipelineName: String) {
        pipelineStartEvents++
    }
    
    override fun recordPipelineCompletion(executionId: String, duration: Duration, status: PipelineStatus) {
        pipelineCompletionEvents++
    }
    
    override fun recordStageExecution(stageName: String, duration: Duration, status: StageStatus) {
        stageExecutionEvents++
    }
    
    override fun recordStepExecution(stepName: String, stepType: String, duration: Duration, status: StepStatus) {
        stepExecutionEvents++
    }
}